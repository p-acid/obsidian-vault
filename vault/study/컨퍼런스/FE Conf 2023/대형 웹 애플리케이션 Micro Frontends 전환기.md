---
tags:
  - flex
  - Micro-Frontend
---
![대형 웹 애플리케이션 Micro Frontends 전환기](https://www.youtube.com/watch?v=VnJLFwnuLV4)

# 개요

1. flex 제품 & 코드베이스 소개
2. 문제 탐구의 시작
3. Proof of Concept
4. Actions
5. Migration

# flex 제품 & 코드베이스 소개

- 인사 관리를 위한 올인원 플랫폼을 표방하며 **여러가지 기능을 제공**
	- 회사 구성원의 생애 주기에 발생하는 모든 이벤트를 커버하고자 함
	- 통합의 경험을 제품 속에 구현할 수 있도록 노력
- 그래서 기능 단에서 UI와 서비스가 서로 엮이는 부분이 많아진다.
	- 17개의 앱, 약 8, 7GB의 사이즈
- 팀은 스쿼드 단위로 운영

# 문제 탐구의 시작

- 기존 아키텍처는 각각 제품에 해당하는 여러 Next 앱이 존재하고 이를 인프라 레벨에서 라우팅 해주는 형태
	- `flex.team/*`
- 기존 아키텍처가 가지는 문제
	1. 유저에게 하나의 앱을 쓰는 경험을 전달할 수 없다.
	2. 스쿼드 독립적, 효율적인 개발이 힘들다.

## 유저에게 하나의 앱을 쓰는 경험을 전달할 수 없다

- 각 앱은 각각의 자원(`html`, 번들 등)을 가지고 다른 앱으로 접속하는 경우 앱에 필요한 모든 자원을 가져와야 한다.
- 페이지 간 공통 UI들은 다른 앱으로 넘어가도 유지되는 것들이 있지만, 유저는 다른 앱으로 넘어갈 때 마다 특정 기능의 로딩 서클을 다시 보거나 이미 불러온 것 들을 다시 불러오는 경우가 발생한다.

## 스쿼드 독립적, 효율적인 개발이 힘들다

- 네비게이션 영역의 컴포넌트가 수정되었을 때, 해당 코드베이스가 포함되는 모든 앱을 롤백해야 해서 스쿼드 독립적으로 개발하는 과정이 어려워졌다.

## Module Federation

- 마이크로 프론트엔드 구현 방식 중 하나로, 하나의 앱을 독립적인 배포가 가능한 모듈 단위(자바스크립트 번들)로 나누어 브라우저의 런타임에 동적으로 통합하는 방식
- 빌드 타임이 아닌 런타임에 합치는 방식으로 분리된 앱들이 각각의 개발 프로세스를 자바스크립트 번들의 형태로 배포되고 각각의 마이크로 앱들은 호스트라고 불리는 앱에서 로드되어 각각 따로 렌더링 되게 된다.

## 기존 문제점의 해결

- [x] 유저에게 하나의 앱을 쓰는 경험을 전달할 수 없다.
	- 런타임에는 하나의 앱으로
- [x] 스쿼드 독립적, 효율적인 개발이 힘들다.
	- 배포 단위를 페이지 이하의 단위로 더 작게 쪼개서 런타임에 통합

### 추가적인 이점

- 앱 내 리액트 컴포넌트를 자연스럽게 쪼개서 배포 단위를 만들고 번들로 빌드하면서 배포하여 앱 내부에서는 코드 스플리팅을 한 것 처럼 로드 시에 자연스럽게 한 앱에 통합이 된다는 점이 매력적이라 느낌

# Proof of Concepts

- Micro Frontend 체험존 제공
	- 모듈 단위의 앱이 어떻게 로드되는 지 확인할 수 있는 작은 SPA 앱을 제공
- 기존 아키텍처에 Module Federation을 적용할 수 있을까?
	- `@module-federation/nextjs-mf` 패키지
	- 동작하는 것은 확인할 수 있었으나, Next가 만들어 놓은 마이크로 프론트엔드 구현을 위한 권장방식을 확인하였을 때 Module Federation을 공식적으로 제공할 계획이 없다고 한 것을 확인
	- 커뮤니티 기반의 플러그인에 커다란 프로덕션 제품을 의존시키기에는 리스크가 크다.
	- 그렇기에 결론은 Next와 Module Federation은 같이 갈 수 없다고 판단

## Nextjs를 떼어낸 이유

- 기존 Next에서 제공하는 SSR을 직접 구현해서 사용하기엔 리소스가 너무 크기에 포기해야 한다.
- 하지만 제품 특성 상 B2B Sass라 SEO 등 SSR에서 강점을 보일 수 있는 부분이 적기에 당시 제품에서는 일부 UI에서만 SSR을 활용했었다.

## Trade-off

1. 초기 렌더링 성능 저하와 LCP 악화
	- flex의 경우 초기 렌더링 성능만큼 앱 사용 중 경험도 중요하다.
	- SSR과 상관 없는 성능 개선 포인트도 존재하기에 아키텍처 마이그레이션과 별도로 갈 수 있다고 판단.
2. 단기적으로 SSR을 포기하지만 추후에는 필요할 수 있다.
	- Nextjs에서 처럼 서버를 같이 구현하여, 추후 SSR을 구현해 사용할 수 있도록 한다.
		- 여기서 서버는 클라이언트 리소스를 전달하는 서버

## PoC에서 감지하지 못한 문제가 발생한다면?

- 우리가 도입하고자 하는 것은 Micro Frontends이지, Module Federation이 아니다.
- 앱은 계속 커질 것이며 당면한 문제는 커진다. 결국 Micro Frontends는 가야할 길이다.

# Actions

## 팀 차원의 자신감 향상시키기

> 지식 공유, 팀 전체의 지식 수준 향상 및 데모 환경 배포로 남은 가설 검증

- 팀 내 공유 활동 활성화(코드 설명회, 도식화 정보 제공, QA 세션 제공)
- 프로덕션과 유사한 형태로 체험존 앱을 구현
	- 프로덕션과 동일한 사내 인프라를 이용하여 데모 환경 배포
	- 빌드 및 배포 과정을 미리 경험하고 이슈 식별

## 새 애플리케이션 기반 다지기

> Micro Frontends의 리스크 완화

### Module Federation 전방향(Omnidirectional) 리스크

- 전방향 마이크로 앱이 연결되는 경우 의존성이 복잡해지는 문제가 발생할 수 있다.
	- 앱의 구조를 파악하기 힘든 비효율 발생
- 앱 전역의 호스트를 하나만 두고 호스트가 여러 리모트를 부를 수 있는 구조를 코드베이스에서 `config` 로 강제

### 런타임 에러 리스크

- 런타임 통합이라는 요소때문에 빌드나 배포 단에서 식별되지 않은 에러가 런타임에서 발생하여 유저 경험을 낮추는 리스크를 내포
- 리모트 앱 로드 실패에도 앱의 다른 기능을 사용할 수 있도록 에러 격리 처리에 만전을 기함
- 로컬 환경에서 두 가지 개발 환경 제공
	- `dev:multiple`: host, gnb 앱을 함께 로컬 개발 서버에 띄우고 각각 다른 포트에 앱이 띄워지며, **런타임 안정성을 검증**할 수 있다.
	- `dev:standalone`: 특정 Remote 앱 하나만 로컬 개발 서버로 띄워 **개발 속도에 이점**이 생김

## 기능 개발 속도 최대한 유지하기

- 점진적인 마이그레이션이 어려운 상황
	- Next.js에서 전면 SPA로의 전환은 좋지 않은 네비게이션 경험을 준다.
- 프레임워크 의존성 없는 앱 페이지 단위의 리액트 컴포넌트들을 모노레포 내부 패키지로 분리하고 기존 앱과 마이크로 앱에 동시에 의존하게 만들어 빌드를 성공시키는 방식
	- 기능 개발이 진행되는 패키지 형식의 리액트 컴포넌트를 두 가지 앱에서 `import` 하는 방식
- 호환 패키지 대체하기
	- 빌드 시점에서 `webpack` 의 `alias` 설정을 통해 리액트 라우터 패키지로 변경

## 전사가 참여하는 마이그레이션 QA

- 점진적 환경 대체 및 이슈 식별
	- 브라우저 쿠키(App-Type)를 통해 기존 앱과 마이크로 프론트엔드 앱 간의 전환이 가능하도록 설정
	- 이를 통해 QA 팀에서 기능 혹은 아키텍쳐 이슈인지 식별한 이후 해당하는 팀에게 전달
- 일하는 환경도 함께 마이그레이션
