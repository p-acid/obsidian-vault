![SSR 환경(Node.js) 메모리 누수 디버깅 가이드](https://www.youtube.com/watch?v=P3C7fzMqIYg)

# 메모리 누수의 정의와 문제점

> 필요 없는 것들이 메모리를 차지한다.

## 문제점

- 자바스크립트를 동작시킬 메모리가 부족하여 성능이 떨어진다.
	- 가비지 콜렉션의 활동이 늘어나면, CPU 사용량이 늘어난다.
	- CPU Intensive 한 작업이 늘어나면 이벤트 루프가 블로킹되어 연산이 느려진다.
- 띄워놓은 Node.js 서버가 죽는다.
	- SIGABRT 등의 시그널로 인한 프로세스 종료
	- 인스턴스가 재시작되고 일부 요청에 대한 응답이 실패할 수 있다.
	- 로드밸런서가 HTTP Status 502(Bad Gateway) 에러를 뱉을 수 있다.
	- 가용성에 문제가 있을 수 있다.

# 해결 방법

- 힙메모리를 늘려준다.
- 메모리 누수의 원인을 디버깅한다.

## 메모리 누수를 파악한 방법

```sh
Allocation failed - Javascript heap out of memory
```

- 해당 오류가 발생하는 경우 힙메모리 오류일 가능성이 높다.

## 모니터링 방법

- 메모리 누수가 발생하는 부분은 모니터링 툴 그래프에서 어떻게 반영되는가?
	- 메모리 누수가 없으면 평탄한 형태의 그래프가 만들어지고, 메모리 누수가 있는 경우 산 모양의 그래프를 만들게 된다.

## 힙메모리를 늘리면 어떻게 될까

- 힙메모리를 늘린다고 해도 계속 메모리 누수가 발생하여 서버는 다운될 것이다.
	- V8의 메모리 누수 방식을 알면 이해하기 쉽다.

> [!info]
>  V8은 Mark And Sweep이라는 메모리 관리 방식을 사용하는데. 말 그대로 사용하는 메모리는 Mark 하고 그렇지 않은 메모리는 Sweep 하는 것이다. 객체는 힙메모리에 할당되는데 GC(가비지 콜렉션)은 계속 이 부분을 체크하여 수거해간다.
>  
>  V8의 GC 힙메모리 관리를 위해 메모리 관리를 분기에 따라 나누어 관리한다. 계속 메모리가 GC를 피해 살아남게 된다면 Old Generation 영역의 메모리가 가득 차기 떄문에 포화되어 서버가 죽게 된다.

## 대표적인 메모리 누수 요인들

1. 전역 변수
2. 해제되지 않은 타이머(`clearTimeout` 등)
3. 클로저

## 메모리 누수의 원인을 디버깅 해보자

```sh
# 서버 환경에서 가능
node --inspect index.js
```

- 위와 같이 실행하면 크롬의 inspect를 통해 하나의 창을 열 수 있다.
- **Allocation instrumentation on timeline** 옵션을 통해 녹화하는 동안 주기적으로 힙메모리 할당 정보를 기록한다.
	- 주로 이 방법을 사용한다.
- 회색 그래프는 현재 사용 중인 힙메모리의 양이고 파란색 그래프는 GC가 안 된 힙메모리의 비율이다. 파란색 그래프가 위치한 곳이 힙메모리 누수의 주된 원인이다.

> [!note] 
>**사이즈 관련 지식**
> 
> - `Shallow Size`: 오브젝트 자신의 크기(bytes)
> - `Retained Size`: 나 자신 + 참조하고 있는 오브젝트들의 크기(bytes) 
>   
>   `Shallow Size` 에 비해 `Retained Size` 가 유난히 큰 요소들에 주목하자.

# 앞으로 주목할 것들

- `using` 키워드
	- `let`, `const`, `bar` 대신 변수를 선언하는 키워드
	- 스코프 끝에서 `Symbol.dispose()` 를 호출하여 클린업 할 수도 있다.
